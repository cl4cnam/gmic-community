#@gmic
#
# G'MIC filters from Arto Huotari. All filters lisenced under the same Cecill lisence as G'MIC
#

#####################################################################
# Artistic Folder
#####################################################################
#@gui _<b>Artistic</b>

#****************************************
# Dream smoothing
#****************************************
#@gui Dream Smoothing : fx_dreamsmooth, fx_dreamsmooth_preview(0)
#@gui : note = note("Updated for 1.5.4.0")
#@gui : note = note("A relatively slow filter that uses anisotropic filtering to smooth an image. More iterations produces softer image as does lower opacity values. Practical modes for merging are Alpha and Average. Note that results are resolution dependent.")
#@gui : sep = separator(), note = note("General settings")
#@gui : Iterations = int(3,1,10)
#@gui : Equalize at Each Step = bool(1)
#@gui : sep = separator(), note = note("Merging of iterations")
#@gui : Merging Option = choice(1,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor","edges")
#@gui : Opacity = float(0.8,0,1)
#@gui : Reverse Order = bool(0)
#@gui : note = note("Settings for layer mode edges")
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator()
#@gui : note = note("Parallel processing settings. Increase spatial overlap if vertical bands appear.")
#@gui : Parallel Processing = choice(1,"Auto","One thread","Two threads","Four threads","Eight threads","Sixteen threads")
#@gui : Spatial Overlap = int(24,0,256)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2014/02/20</i>.</small>")
#@gui : note = link("Sample processing here","http://www.flickr.com/photos/naggobot/7644006608/")
fx_dreamsmooth :
  m "MergeChoise : $""=_mode" MergeChoise "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
  to_color
  Iterations=$1
  Eqa=$2
  MergingOption=$3
  Opacity=$4
  ReverseOrder=$5
  Smoothness=$6
  Threads=$7
  Overlap=$8

  # Handle multiple layers
  repeat $! l[$>] split_opacity l[0]

    # Enter loop and smooth first image
    repeat $Iterations

      # Calculate width and height
      IWidth={0,round(w/($<+1))}
      IHeight={0,round(h/($<+1))}
      # Resize previously processed image. Not done on first repeat loop since there is no such image yet.
      if $>!=0
        # Resize [image_w],[image_h],[image_d],[image_s],_interpolation,_boundary,_ax,_ay,_az,_ac
  r. $IWidth,$IHeight,1,3,5,1
      fi

      # Resize and make a copy
      +r[0] $IWidth,$IHeight,1,3,5,1 # Image 1 and on loop 2 image 2 / -1 and -2

      # Smoothing
      fx_smooth_anisotropic. {430/$Iterations*($<+1)},0.4,0.5,0.6,2,0.8,30,2,0,0,1,0,$Threads,$Overlap,0
      fx_smooth_anisotropic. {600/$Iterations*($<+1)},0.4,1,0.6,4,0.8,15,5,0,1,1,0,$Threads,$Overlap,0

      # Combine images if not first round
      if $>!=0
        # Something wrong with this boolean. It does not work.
 if $3!=42
   blend[-1,-2] ${_mode{$MergingOption+1}},$Opacity,$ReverseOrder
 fi
 if $3==42
   blend_edges[-1,-2] $Opacity,$Smoothness,$ReverseOrder
 fi
 if $Eqa
   equalize. 256
 fi
      fi
    done
    k.
    # End command for multilayer handling block
  done a c done done

fx_dreamsmooth_preview :
  gui_split_preview "fx_dreamsmooth ${1--2}",$-1

#****************************************
# Morphology painting
#****************************************
#@gui Morphology Painting : fx_MorphoPaint, fx_MorphoPaint_preview(0)
#@gui : sep = separator()
#@gui : note = note("Creates a painting using Morphology-, Segmentation- and Painting- filters. CPU intensive filter that may take long.")
#@gui : sep = separator()
#@gui : note = note("Morphology settings")
#@gui : sep = separator()
#@gui : Method = choice(1,"Erosion","Dilation","Opening","Closing")
#@gui : MorphoStrenght = int(18,2,60)
#@gui : Shape = choice(2,"Square","Octagonal","Circular")
#@gui : sep = separator()
#@gui : note = note("Lightness for Morpholayer")
#@gui : Black Point = int(25,0,50)
#@gui : Expand Shadows = int(100,50,255)
#@gui : Compress Highlights = int(230,200,255)
#@gui : sep = separator()
#@gui : note = note("Smoothing strength")
#@gui : Spread Amount = int(8,0,20)
#@gui : Blur Strength = int(3,0,10)
#@gui : sep = separator()
#@gui : note = note("Segmentation settings")
#@gui : Edge Threshold = float(4,0,15)
#@gui : Smoothness = float(0.5,0,5)
#@gui : sep = separator()
#@gui : note = note("Painting Settings")
#@gui : Abstraction = int(2,1,10)
#@gui : Details Scale = float(0.5,0,5)
#@gui : Smoothness = float(200,0,1000)
#@gui : sep = separator()
#@gui : Merge Layers? = bool(1)
#@gui : note = note("When unchecked the filter will output layers separately for manual composing. Set G'Mic output to new layers.")
#@gui : sep = separator()
#@gui : Enable Paintstroke = bool(1)
#@gui : Stroke Strength = float(1,0,1)
#@gui : Enable Segmentation = bool(1)
#@gui : Segments Strength= float(1,0,1)
#@gui : Enable Morphology = bool(1)
#@gui : Morphology Strength= float(1,0,1)
#@gui : Normalize = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6108637935/")
fx_MorphoPaint :
  to_rgb[0]
  +fx_morpho[0] $1,$2,0,2,0,$3,0 # Morpho as nro 1
  +fx_apply_curve[1] $4,50,$5,200,$6,-1,128,-1,128,-1,128,255,1,3,0,0,0 # Curved morpho as nro 2
  fx_spread[1] $7,$7,0,0 # Spread Morpho nro 1
  fx_gaussian_blur[2] $8,0,0,1,0,0,0 # Blur Morpho+Spread nro 1
  fx_segment_watershed[1] $9,$10,0,0 # Segment Morpho+Spread+Blur nro 1
  +fx_painting[0] $11,$12,1.5,$13,1,0 # Paint from original nro 0
  rm[0] # Remove original from stack
  rv[0,2] # Reverse images to logical order (Important if output to Gimp)
  rv[1,2]
  if $14
    if $19==0 MorphoStrength={0} elif $19==1 MorphoStrength={$20} fi  # Set layer value to zero if enabled
    *[2] {$MorphoStrength/3} # Morphology
    if $15==0 StrokeStrength={0} elif $15==1 StrokeStrength={$16} fi  # Set layer value to zero if enabled
    *[0] {$StrokeStrength/3} # Paint stroke
    if $17==0 SegmentStrength={0} elif $17==1 SegmentStrength={$18} fi # Set layer value to zero if enabled
    *[1] {$SegmentStrength/3} # Segments
    +[1] [2] # Combine images
    +[1] [0]
    if $21 n[1] 0,255 fi # Conditional normalize to get the image to correct range
    rm[0,2] # Remove extra images
  fi

fx_MorphoPaint_preview :
  gui_split_preview "fx_MorphoPaint ${1--2}",$-1

#****************************************
# Simple Noise canvas
#****************************************
#@gui Simple Noise Canvas : fx_SimpleNoiseCanvas, fx_SimpleNoiseCanvasPreview(0)
#@gui : note = note("Simpe noise based xy canvas effect. Preserve canvas and bumpmap image with canvas after filtering for best results. Merge option DoNothing outputs only original image if Preserve canvas option is not selected.")
#@gui : sep = separator()
#@gui : Scale Factor = float(0,0,1)
#@gui : sep = separator()
#@gui : note = note("Noise Parameters")
#@gui : Amplitude = float(3,0,20)
#@gui : Noise Type = choice(2,"Gaussian","Uniform","Salt and Pepper","Poisson")
#@gui : sep = separator()
#@gui : note = note("Thread Length")
#@gui : Horisontal Length = float(5,2,15)
#@gui : Vertical Length = float(5,2,15)
#@gui : Overall Blur = float(0,0,15)
#@gui : Canvas Brightness = float(255,230,255)
#@gui : Canvas Darkness = float(0,0,255)
#@gui : sep = separator()
#@gui : note = note("How to combine XY threads")
#@gui : Merging Option = choice(2,"Average","Multiply","Darken","Edges")
#@gui : Invert Canvas Colors = bool(0)
#@gui : Invert Image Colors = bool(0)
#@gui : note = note("How to combine image + canvas")
#@gui : Reverse Order = bool(0)
#@gui : Merging Option = choice (1,"Avg","Multiply","Scr","Darken","Lighten","Dif","Negation","Exclusion","Overlay","Hardlight","Softlight","Dodge","Colorburn","Reflect","Freeze","Stamp","Interpolate","Grainext","Grainmerge","Xor","Edges","DoNothing")
#@gui : Preserve Canvas for Post Bump Mapping = bool(0)
#@gui : Canvas Color = color(255,255,255,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6152040642/")
fx_SimpleNoiseCanvas :

  # Filter has some unnecessary reversing of layers due to change from compose to blend
  CanvasScale={$1}
  NoiseAmplitude=$2
  NoiseType=$3
  ThreadHorizLen=$4
  ThreadVertLen=$5
  OverAllBlur=$6
  HighCut=$7
  LowCut=$8
  CanvasMergeChoice=$9
  InvertCanvasColors=$10
  InvertImageColors=$11
  ReverseChoice=$12
  MergeChoice=$13
  PreserveCanvas=$14
  # (Remember that color is set directly with param 15-17)

  # Remove alpha channel from image
  to_rgb[0]

  # Invert scale factor for scaling
  CanvasScale={1.2-$CanvasScale}

  # Make white base image with specified color and resize it to inputimage size
  (255^255^255)
  ri. [0]

  # Resize to scale factor
  r[1] {100*$CanvasScale}%,{100*$CanvasScale}%

  # Add noise
  if $NoiseType!=2 NoiseAmplitude={$NoiseAmplitude*10} fi
  fx_noise[1] $NoiseAmplitude,$NoiseType,0,1,0
  # Make noise BW
  fx_ditheredbw[1] 1,1,0,0,0,0 # [G'MIC] B&W dithering
  # Blur X for noize, make new image
  +fx_gaussian_blur[1] 0,$ThreadHorizLen,0,1,0,0,0 # image 2
  # Blur y for noize, make new image
  +fx_gaussian_blur[1] 0,0,$ThreadVertLen,1,0,0,0 # image 3
  n[2] 0,255
  n[3] 0,255

  # Combine canvas
  if $CanvasMergeChoice==0 blend[2,3] average
  elif $CanvasMergeChoice==1 blend[2,3] multiply
  elif $CanvasMergeChoice==2 blend[2,3] darken
  elif $CanvasMergeChoice==3 blend_edges[2,3] 0.9
  fi

  # OverAllBlur
  fx_gaussian_blur[2] $OverAllBlur,0,0,1,0,0,0 # image 3

  # Remove noise image
  rm[1]

  # Scale canvas back to image size
  ri[1] [0]

  # Make color and transfer it
  ($15^$16^$17) # image 2
  ri[2] [0]
  blend[1,2] multiply

  # Adjust range
  fx_apply_curve {$LowCut},-1,128,-1,128,-1,128,-1,128,-1,128,{$HighCut},1,3,0,0,0

  # Reverse if requested
  if $ReverseChoice==1 rv[0,1] fi

  # Invert canvas colors if requested
  if $InvertCanvasColors==1 negate[1] fi

  # Invert Image colors if requested
  if $InvertImageColors==1 negate[0] fi

  # Combine to original
  if $MergeChoice==0 +blend[1,0] average # Image 2
  elif $MergeChoice==1 +blend[1,0] multiply
  elif $MergeChoice==2 +blend[1,0] screen
  elif $MergeChoice==3 +blend[1,0] darken
  elif $MergeChoice==4 +blend[1,0] lighten
  elif $MergeChoice==5 +blend[1,0] difference
  elif $MergeChoice==6 +blend[1,0] negation
  elif $MergeChoice==7 +blend[1,0] exclusion
  elif $MergeChoice==8 +blend[1,0] overlay
  elif $MergeChoice==9 +blend[1,0] hardlight
  elif $MergeChoice==10 +blend[1,0] softlight
  elif $MergeChoice==11 +blend[1,0] dodge
  elif $MergeChoice==12 +blend[1,0] colorburn
  elif $MergeChoice==13 +blend[1,0] reflect
  elif $MergeChoice==14 +blend[1,0] freeze
  elif $MergeChoice==15 +blend[1,0] stamp
  elif $MergeChoice==16 +blend[1,0] interpolation
  elif $MergeChoice==17 +blend[1,0] grainextract
  elif $MergeChoice==18 +blend[1,0] grainmerge
  elif $MergeChoice==19 +blend[1,0] xor
  elif $MergeChoice==20 +blend_edges[1,0] 0.8
  fi

  # Reverse original and canvas if it was done previously
  if $ReverseChoice==1 rv[0,1] fi
  # Remove canvas if not asked to preserve
  if $PreserveCanvas==0 rm[1]  fi
  # PreserveCanvas=1
  if $PreserveCanvas==1" && "$MergeChoice!=21 rv[1,2]  fi

  # Remove original if merging is done
  if $MergeChoice!=21 rm[0] fi

  # Switch items for correct preview
  if $MergeChoice!=21" && "$PreserveCanvas==1 rv[0,1] fi

fx_SimpleNoiseCanvasPreview :
  gui_split_preview "fx_SimpleNoiseCanvas ${1--2}",$-1

######################################
# Gimp pastell
#####################################
#@gui Pastell Art : fx_pastell, fx_pastell_preview(1)
#@gui : MasterOpacity = float(0.6,0.3,1)
#@gui : BG Textured = bool(1)
#@gui : Reverse Effect = bool(0)
#@gui : sep = separator(),note = note("Rodilius settings")
#@gui : Amplitude = float(20,0,30)
#@gui : Thickness = float(30,0,100)
#@gui : Sharpness = float(300,0,1000)
#@gui : Orientations = int(1,1,36)
#@gui : Offset = float(30,0,180)
#@gui : Color Mode = choice(1,"Darker","Lighter")
#@gui : sep = separator(),note = note("Gradient settings")
#@gui : Smoothness = float(1,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Negative Colors = bool(0)
#@gui : sep = separator(),Activate Shakes = bool(0)
#@gui : Amount = float(10,0,30)
#@gui : Strength = float(3,1,300)
#@gui : sep = separator(),Activate Lizards = bool(0)
#@gui : Toes = float(9,0,300)
#@gui : Shivers = float(3,0,4)
#@gui : sep = separator(),Activate Pink elephants = bool(0)
#@gui : Trunks = float(12,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6294075073/")
fx_pastell :
  # Filter may have some unnecessary reversing of layers due to change from compose to blend
  # Variables
  MasterOpacity=$1
  BgTextured=$2
  ReverseEffect=$3
  RAmplitude=$4
  RThickness=$5
  RSharpness=$6
  ROrientations=$7
  ROffset=$8
  RColormode=$9
  GSmoothness=$10
  GLinearity=$11
  GNegativeColors=$12
  ActivateShakes=$13
  RiAmplitude=$14
  RiSize=$15
  ActivateLizards=$16
  WAmplitude=$17
  WSmoothness=$18
  ActivatePink=$19
  RDeform=$20

  # Constants
  RChannels=0
  GMinThreshold=0
  GMaxThreshold=100
  RiShape=3
  RiAngle=135

  # Code
  if $ActivatePink==1 deform[0] $RDeform fi
  +fx_rodilius[0] $RAmplitude,$RThickness,$RSharpness,$ROrientations,$ROffset,0,$RColormode,$RChannels,0 # img1
  +fx_gradient_norm[0] $GSmoothness,$GLinearity,$GMinThreshold,$GMaxThreshold,$GNegativeColors,0 # img2
  fx_smooth_bilateral[0] 15,10,3,3,0
  if $ActivateLizards==1 water[0,2] $WAmplitude,$WSmoothness fi
  if $ActivateShakes==1 ripple[0,2] $RiAmplitude,$RiSize,$RiShape,$RiAngle,0 fi
  if $ReverseEffect==1 rv[0,2] fi
  +blend[0,2] divide,1,0 # img3
  rv[1,3]
  blend[1,3] value,1,0 # img1
  if $BgTextured==1 fx_ellipsionism[0] 20,2,10,0.5,1,1,0 fi
  blend[0,1] alpha,$MasterOpacity,0
  k[0]

fx_pastell_preview :
  gui_split_preview "fx_pastell ${1--2}",$-1

######################################
# ColorAbstractionPaint
#####################################
#@gui Color Abstraction Paint : fx_ColorAbstractionPaint, fx_ColorAbstractionPaint_Preview(0)
#@gui : Abstraction = int(5,1,10)
#@gui : Ellipse Ratio = float(10,1,100)
#@gui : sep = separator(),note = note("Opacities, try 0 to see individual effect layers")
#@gui : Ellipsionism Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : Use as Hue = bool(0)
#@gui : Painting Opacity = float(1,-1,1)
#@gui : sep = separator()
#@gui : Use as Saturation = bool(0)
#@gui : Color Abstraction Opacity = float(1,-1,1)
#@gui : Negative Color Abstraction = bool(0)
#@gui : Cubism on Color Abstraction = bool(0)
#@gui : Kuwahara on Painting = bool(0)
#@gui : Soften = float(0,0,100)
#@gui : Soften All Channels = bool(0)
#@gui : DoNotMergeLayers = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : note = link("Sample art here","http://www.flickr.com/photos/naggobot/6640743133/")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2014/02/23</i>.</small>")

fx_ColorAbstractionPaint :
  # Filter may have some unnecessary reversing of layers due to change from compose to blend
  # Alternative merge is Ellipsionism->Value, Painting -> Hue, Color -> Saturation
  # Force rgb
  to_rgb

  # Ellipsionism
  pAbstraction=$1
  EllipseRatio=$2
  ValueOpacity=$3
  UseHue=$4
  MultiplyOpacity=$5
  UseSaturation=$6
  GrainMergeOpacity=$7
  NCA=$8
  CubeIt=$9
  KuwaIt=$10
  Soften=$11
  SoftenAll=$12
  DoNotCompose=$13
  ReverseOrder0=1
  ReverseOrder1=1
  ReverseOrder2=1
  eSmoothness=1
  eOpacity=0.8
  eOutline=1
  eDensity={1.5*$eSmoothness/10}
  # Painting p
  pDetailsScale={$pAbstraction/2}
  pColor=1.5
  pSmoothness={10*$pAbstraction}
  # y=y0+(x-x0)(y1-y0)/(x1-x0)
  # Smoothness Y goes to 10 from 0 when abstraction X goes to 1 from 10
  eSmoothness={10+($pAbstraction-1)*(1-10)/(10-1)}
  ePrimaryRadius={0,($pAbstraction/5)*($pAbstraction/5)*sqrt(h)}
  eSecondaryRadius={$EllipseRatio/100*$ePrimaryRadius}
  cAbstraction={2+($pAbstraction-1)*(10-2)/(10-1)}
  # CubeSize={$ePrimaryRadius*$cAbstraction/30}
  CubeSize={4+($pAbstraction-1)*(10-4)/(10-1)}

  +fx_ellipsionism[0] $ePrimaryRadius,$eSecondaryRadius,$eSmoothness,$eOpacity,1,$eDensity,0 # 1 # -3
  if $SoftenAll==1" && "$Soften>0 b. $Soften,0 fi
  +fx_painting[0] $pAbstraction,$pDetailsScale,$pColor,$pSmoothness,1,0 # 2 # -2
  if $KuwaIt==1 fx_kuwahara. 2,$pAbstraction,0,0 fi
  if $Soften>0 b. $Soften,0 fi
  +fx_color_abstraction[0] $cAbstraction,45,0.35,0 # 3 # -1
  # If negative then invert colors of -1
  if $NCA==1 negate. fi
  if $CubeIt==1 cubism. 600,$CubeSize,40,0.7,0 fi
  if $Soften>0 b. $Soften,0 fi
  if $DoNotCompose==0
    # Compose Original and Ellipsionism with value
    blend[0,1] value,$ValueOpacity,$ReverseOrder0 # 0 # -3
    # Compose Original+Ellipsionism with painting
    if $MultiplyOpacity<0
      ReverseOrder1=0
      MultiplyOpacity={-1*$MultiplyOpacity}
    fi
    if $UseHue==0
      blend[0,1] multiply,$MultiplyOpacity,$ReverseOrder1 # 0 # -2
    elif $UseHue==1
      blend[0,1] hue,$MultiplyOpacity,$ReverseOrder1
    fi

    # Compose Original+Ellipsionism+Painting with Color abstraction
    if $GrainMergeOpacity<0
      ReverseOrder2=0
      GrainMergeOpacity={-1*$GrainMergeOpacity}
    fi
    if $UseSaturation==0
      blend[0,1] grainmerge,$GrainMergeOpacity,$ReverseOrder2
    elif $UseSaturation==1
      blend[0,1] saturation,$GrainMergeOpacity,$ReverseOrder2
    fi
    k[0]
  fi
  if $DoNotCompose==1 rm[0] fi

fx_ColorAbstractionPaint_Preview :
  gui_split_preview "fx_ColorAbstractionPaint ${1--2}",$-1

#****************************************
# Make Squiggly
#****************************************
#@gui Make Squiggly : fx_Squiggly, fx_Squiggly_Preview(0)
#@gui : note = note("Squigles an image")
#@gui : note = note("Squigle parameters")
#@gui : Spread Noise Amount  = float(2,0,20)
#@gui : Segmentation Edge Threshold = float(12,0,15)
#@gui : Segmentation Smoothness = float(0.8,0,5)
#@gui : GradienNormSmoothness = float(0,0,10)
#@gui : GradienNormLinearity = float(0.5,0,1.5)
#@gui : Invert Luminance = bool(1)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note("<b>Optional color enhancement</b>")
#@gui : note = note("Note that the effect of sliders depends on the merge setting.")
#@gui : Activate Color Enhancement = bool(0)
#@gui : Toggle to View Base Image = bool(0), note = note("Check this to view base image")
#@gui : IncreaseChroma1 = float(3,1,4)
#@gui : Tone Threshold = float(0.2,0,1)
#@gui : Tone Gamma = float(0.4,0,1)
#@gui : note = note("Select merging mode to original")
#@gui : Merging Option = choice("Alpha","And","Average","Burn","Darken","Difference","Divide","Dodge","Exclusion","Freeze","Grain extract","Grain merge",
#@gui : "Hard light","Hue","Interpolation","Lighten","Lightness","Luminance","Multiply","Negation","Or","Overlay","Reflect","Saturation",
#@gui : "Soft light","Screen","Stamp","Value","Xor")
#@gui : Opacity = float(1,0,1)
#@gui : Reverse Order = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6667673847/")
fx_Squiggly :

  # Variables
  SpreadNoiseAmount=$1
  SEgThrshld=$2
  SegSmooth=$3
  GNSmooth=$4
  GNLin=$5
  InvertLuminance=$6
  EnhanceColors=$7
  ToggleOrg=$8
  Chroma=$9
  ToneTr=$10
  ToneGm=$11
  OrgMergeCh=$12
  OrgOpacity=$13
  OrgReverseorder=$14

  repeat $! l[$>]

    # Enable original preview from color enhancement section
    if $ToggleOrg==1
      OrgMergeCh=30
      OrgReverseorder=1
    fi

    # Remove alpha channel, something goes wrong if image has aplha
    to_rgb

    +fx_spread[0] $SpreadNoiseAmount,$SpreadNoiseAmount,0,0  # Spread noise (image1)
    fx_segment_watershed[1] $SEgThrshld,$SegSmooth,0,0   # Segmentation (image1)
    +fx_gradient_norm[1] $GNSmooth,$GNLin,0,100,0,0 # Gradient norm (image2)

    # Create colorized squiggle
    +blend[2,1] multiply # image 3

    # Make bg white
    if $InvertLuminance==1
      # Convert to LAB
       rgb2lab.
       # Split channels
       s. c
       negate...
       a[-3--1] c
       lab2rgb.
    fi

    if $EnhanceColors==1
       # Increase chroma
       fx_mix_ycbcr[3] 1,0,0,$Chroma,0,0,$Chroma,0,0,0,2,0 # image 3
       # Tonemap original
       fx_map_tones[0] $ToneTr,$ToneGm,0.1,30,0,0 # image 0
       # fx_apply_curve[0] 0,30,128,-1,128,-1,128,-1,128,-1,128,255,1,3,0,0,0
       # Compose Squigglies to original
       fx_blend[0,3] $OrgMergeCh,0,$OrgOpacity,0,0
       k[0]
    fi
    k.
  done done

fx_Squiggly_Preview :
  gui_split_preview "fx_Squiggly ${1--2}",$-1

#################################################################################################################
#@gui _<b>Details</b>
#################################################################################################################

#******************************************
# USM WITH LCE
#******************************************
#@gui Local Contrast Enhancement : fx_LCE, fx_LCE_preview(0)
#@gui : note = note("Local contrast enhancement is <i>Unsharp Mask</i> with high radius. Apply filter to RGB channels for color and contrast enhancement.")
#@gui : Spatial Radius = float(80,30,200)
#@gui : Amount = float(0.5,0,5)
#@gui : Darkness Level = float(1,0,4)
#@gui : Lightness Level = float(1,0,4)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : note = note{"\n\n<small><b>Note : </b>
#@gui : Original USM code by <i>by David Tschumperl&#233;</i>.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Authors : <i>Arto Huotari, PhotoComiX</i>.      Latest update : <i>2013/03/23</i>.</small>")
_fx_LCE :
  SpatialRadius=$1
  Amount=$2
  DarknessLevel=$3
  LightnessLevel=$4
  # Since LCE a threshold of 0 is used always
  Threshold=0
  +b. $SpatialRadius
  -. .. *. -$Amount
  +norm. ge. $Threshold% ri. .. *[-2,-1]
  +c. 0,100% c.. -100%,0 *.. $DarknessLevel *. $LightnessLevel +[-2,-1]
  +[-2,-1] c. 0,255

fx_LCE :
  ac "_fx_LCE $1,$2,$3,$4",$5,0

fx_LCE_preview :
  gui_split_preview "fx_LCE ${1--2}",$-1

#******************************************
# YAG effect
#******************************************
#@gui YAG Effect : fx_yag_soften, fx_yag_soften_preview(0)
#@gui : Darken  = float(0,0,100)
#@gui : Soften  = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6260257923/")
fx_yag_soften :
  Darken=$1
  Soften=$2
  # Make sharpener layer
  +fx_laplacian[0] 0,0,100,0,0,0 # image 1
  # Blur laplacian
  if $Soften>0
    fx_gaussian_blur[1] {$Soften/10},0,0,1,0,0,0
  fi
  # Make soft and vivid
  +fx_mix_lab[0] 0.5,50,0.2,1,2,1,1,2,1,0,10,0 # image 2
  # Make darkener mask with softlight
  # Multiply with previous darkener mask
  if $Darken>0
    +blend[0,2] softlight # image 3
    blend[0,3] multiply,{$Darken/100}
  fi
  # Compose soft and vidid with hardlight
  blend[0,2] hardlight # image0 is modified, image 2 is removed
  # Sharpen with grainextract
  if $Soften!=100
    blend[0,1] grainextract # Image 0 image 1 is removed
  elif $Soften==100
    rm[1]
  fi

fx_yag_soften_preview :
  gui_split_preview "fx_yag_soften ${1--2}",$-1

###################################################################################################################
#@gui _<b>Testing</b>
###################################################################################################################

#@gui Naggobot
#******************************************
# Import 16 bit image
#******************************************
#@gui Import 16bits Image : fx_import_image_16, fx_import_image_16
#@gui : note = note("Filter can be used to import and adjust 16 bit images to Gimp. Plugin may have limited set of import formats available depending on compilation. At minimum only .png should work reliably.")
#@gui : note = note("1. Create new empty image to Gimp")
#@gui : note = note("2. Open G'Mic from filters menu")
#@gui : note = note("3. Set G'Mic output to "new layers")
#@gui : note = note("4. Select 16 bit image from folder")
#@gui : note = note("5. Make adjustments using sliders")
#@gui : note = note("6. Image will be outputted to Gimp")
#@gui : note = note("By default a scaled down image is processed. Before processing full size disable preview window from gui.")
#@gui : note = note("LAB adjustment often yields more aesthetic results than RGB adjustment.")
#@gui : Input Image = file()
#@gui : Process Selection = choice(1,"Preview Only", "Histogram", "Logarithmic Histogram", "Full resolution")
#@gui : Gamma = float(2.2,0,5)
#@gui : sep = separator(), note = note("LAB adjustment")
#@gui : Brightness = float(0,-1,1)
#@gui : Contrast = float(1,0,3)
#@gui : Equalize = float(0,0,1)
#@gui : Saturation = float(0,-1,10)
#@gui : A(R-G) = float(0,-1,1)
#@gui : B(Y-B) = float(0,-1,1)
#@gui : sep = separator(), note = note("RGB cut and normalize histogram by percentage")
#@gui : Cut Highlight Values = float(100,0,100)
#@gui : Cut Dark Values = float(0,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>Arto Huotari;</i>.      Latest update: <i>2014/04/02</i>.</small>")
fx_import_image_16 :
  # Variables
  ProcessTo=$2
  Gamma=$3
  Brightness=$4
  Contrast=$5
  Equalize=$6
  AB=$7
  A=$8
  B=$9
  CutHigh=$10
  CutLow=$11
  # Remove import image
  rm i
  # Import image from disk
  "$1"
  # Make sure that the input is rgb
  to_rgb
  # Scale down to preview size
  if $ProcessTo!=3
    resize2dx 520,1
  fi
  apply_gamma $Gamma
  # Check if image has pixelvalues over 255
  # Correct only for gamma if not
  if {0,iM>256}
    if $Equalize
      +equalize 65535
      blend alpha,{$Equalize/2}
    fi
    # Scale values to 0 to 1 range
    / 65535
    # Separate luminance from colour
    rgb2lab
    s c
    if $Brightness
      +... $Brightness
    fi
    if $Contrast!=1
      *... $Contrast
    fi
    # Adjust saturation by multiplying both A and B channels
    if $AB
      *.. $AB
      *. $AB
    fi
    # Adjust colour balance by multiplying A or B channel.
    if $A
      *.. {1+$A}
    fi
    if $B
      *. {1+$B}
    fi
    a c
    lab2rgb
    # RGB cut and normalize
    if $CutHigh!=100" || "$CutLow!=0
      Range=1
      # Calculate cut high
      HighValue={$CutHigh/100*$Range}
      # Calculate low value from remaining
      LowValue={$CutLow/100*$HighValue}
      c $LowValue,$HighValue
      n 0,1
    fi
    # Scale to 255 for Gimp
    * 255
    # Cut 0,255 for Gimp
    c 0,255
    if $ProcessTo==1
      +display_histogram {0,w},{0,h},255,0,254,0
      blend lighten,0.7
    fi
    if $ProcessTo==2
      +display_histogram {0,w},{0,h},255,0,254,0,log(1+i)-1
      blend lighten,0.7
    fi
  fi

#******************************************
# Luminance to alpha
#******************************************
#@gui Luminance to Alpha : fx_split_luminance, fx_split_luminance(1)
#@gui : note = note("Filter splits image to different levels of Luminance. Set preview output to "all outputs". Order of output to Gimp from top to bottom is Midtones,Light,LL,..,Dark,DD,.. If reduced overlap is used then first Light layer is removed from output as redundant if more than one level is processed. Mutilevel output becomes Midtones,,LL,LLL,..,Dark,DD,DDD.. with intermediary light and dark levels containing midtones. ")
#@gui : sep = separator()
#@gui : Levels = int (1,1,6)
#@gui : Output as Alpha = bool(1)
#@gui : Reduce Overlap = bool(1)
#@gui : sep = separator(), note = note("Use keep[] or remove[] to select output images")
#@gui : Keep Custom = bool(0)
#@gui : Keep Custom = text(0,keep.)
#@gui : sep = separator(), note = note("<small>Author: <i>Arto Huotari;</i>.      Latest update: <i>2014/04/13</i>.</small>")
intersect_images:
  # Create masks to extract
  # Extract areas in L that are darker than those in D (white shows light areas)
  +lt[0] [1]
  *. 255
  # Extract areas in D that are darker than those in L (white shows dark areas)
  +lt[1] [0]
  *. 255
  # Subtract booleans from L and D -> areas with selected pixels will go to 0 or below
  -[0] .
  -[1] ..
  # Remove booleans
  rm[-1,-2]
  # Cut to 0-1 range - remove areas selected by booleans
  c[0] 0,255
  c[1] 0,255
  # Combine images - this image now contains
  # midtone area pixels but grey values = image pixel values
  +[0] [1]
  rm[1]
  # Normalize to create mask i.e. pixel with value of 127.5
  # will be shown with opacity of 255 when mask is used

create_base_levels:
  Levels=$1
  # Create Lighter levels
  # Darker levels are created by subtracting D from L repeatedly
  # there fore Li=L-i*D
  repeat $Levels-1
    # Multiply D level with loop index+1
    +*[2] {$>+1}
    # Subtract i*D from L
    +-[1] .
    rm..
    c. 0,255
  done

  # Create Darker levels
  # Ligter levels are created by subtracting L repeatedly from D
  repeat $Levels-1
    # Multiply L with loop index + 1
    +*[1] {$>+1}
    # Subtract i*L from D
    +-[2] .
    rm..
    c. 0,255
  done

reorder_stack :
  Levels=$1
  # Subtract overlapping portions from Light masks
  # Stack is now
  #   O, L, D, M, LL,LLL,LLLL,DD,DDD,DDDD
  #   0, 1, 2, 3,  4,  5,   6, 7,  8,   9
  # -10,-9,-8,-7, -6, -5,  -4,-3, -2,  -1
  # Stack needs to be re-arranged to
  #   O,M,L,LL,LLL,LLLL,D,DD,DDD,DDDD
  #   O,M, L, D, _ , LL,LLL,LLLL,DD,DDD,DDDD
  mv[3] 1
  #   O,M, L, D, LL,LLL,LLLL,DD,DDD,DDDD
  if $Levels>1
    rv[2,3]
  #   O,M, D, L,LL,LLL,LLLL,DD,DDD,DDDD to
  #   O,M, _ , L,LL,LLL,LLLL,D,DD,DDD,DDDD
    mv[2] {-$Levels+1}
  fi

reduce_overlap :
  Levels=$1
  repeat $Levels-1
    -[{2+$>}] [{3+$>}]
    c[{2+$>}] 0,255
  done
  repeat $Levels-1
    -[{-$Levels+$>}] [{-$Levels+$>+1}]
    c[{-$Levels+$>}] 0,255
  done
  # Subtract brights and lights from midtones
  -[1] [{-$Levels-1}]
  -[1] .
  c[1] 0,255

fx_split_luminance:
  Levels=$1
  AlphaOutput=$2
  ReduceOverlap=$3
  KeepCustom=$4
  KeepText=$5
  to_rgb
  # L
  +rgb2lab
  s. c
  rm[-1,-2]
  n. 0,255
  # D
  +negate.
  # M
  +intersect_images[-1,-2]
  if $ReduceOverlap==0
    n. 0,255
  fi

  # Create base levels
  create_base_levels $Levels

  # Reorder stack
  reorder_stack $Levels
  # Stack is now  O,M,L,LL,LLL,LLLL,D,DD,DDD,DDDD

  if $ReduceOverlap==1" && "$Levels>1
    reduce_overlap $Levels
  fi

  repeat $!-1
    # add 1 to alpha  and cut 0,225 to avoid cutting of colour channels
    # no idea why this is necessary, it yields correct results
    # Ma and ma are already 0 and even though 1 is added the output is still
    # 0 for transparent areas of the mask.
    +[{$>+1}] 1
    c[$>] 0,255
  done

  # Combine with original
  if $AlphaOutput
    repeat $!-1
      +a[0,1] c
      rm[1]
    done
  fi

  if $ReduceOverlap==1" && "$Levels>1
    # D and L are now equal, remove first
    rm[2]
  fi

  # Remove original
  rm[0]

  if $KeepCustom
    $KeepText
  fi

#****************************************
# Exposure Fusion weight map
#****************************************
#@gui Exposure Fusion Weight Map : fx_ExposureWeightMap, fx_ExposureWeightMapPreview(1)
#@gui : sep = separator()
#@gui : note = note("Create exposure fusion weight map")
#@gui : sep = separator()
#@gui : note = note("Set filter output to "New layers". Copy filter output to corresponding layer mask. Use aligned layers to combine multiple exposures.")
#@gui : sep = separator()
#@gui : Contrast Bias = float(0.3,0,1)
#@gui : Saturation Bias = float(0.3,0,1)
#@gui : Exposure Sigma = float(0.2,0,1)
#@gui : Exposure Bias = float(0.3,0,1)
#@gui : BlurMap = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2014/11/30 v2</i>.</small>")
##@gui : note = link("Based on article","http://research.edm.uhasselt.be/tmertens/papers/exposure_fusion_reduced.pdf")

# Sub, Contrast bias factor, returns absolute laplacian
Sub_Contrast_Bias:
  /. 255
  to_gray.
  laplacian.
  abs.

# Sub, Saturation bias factor, returns standard deviatin of picel values
Sub_Saturation_Bias:
  # 1: Calculate average values
  /. 255
  +s[0] c
  blend[-1,-2,-3] average # Destroyes images 1,2,3, leaves 0 and 1
  # 2: Calculate difference values
  s[0] c #  images ,0, R1,G2,B3; 0 contains average
  # Probable error on removing next image.
  # Commented out on 30.11.2014
  # rm[0]
  +-[0] [1] # images ,0, R1,G2,B3,DR4
  rm[1] # images ,0,,G2,B3,DR4
  +-[0] [1] # images 0,,G1,B2,DR3,DG4
  rm[1] # images ,0,,,B1,DR2,DG3
  +-[0] [1] # images 0,,,B1,DR2,DG3,DB4
  rm[1] # images ,0,,,,DR1,DG2,DB3
  rm[0] # images ,,,,,DR1,DG2,DB3
  # Raise to power
  ^[0] 2 # DR1²
  ^[1] 2 # DR2²
  ^[2] 2 # DR3³
  # sum
  +[1] [2] # DR1²,DR3²+DR2²,DR3²
  rm[2]
  +[0] [1] # DR1²+(DR3²+DR2²),DR3²+DR2²
  rm[1] # DR1²+(DR3²+DR2²)
  # Population has three datapoints, divide by 3
  /[0] 3
  # Standard deviation
  sqrt[0]

# Sub, Exposure bias factor
# Wchannel=exp(-(V-0.5)²/(2*sigma*sigma))
# V-0.5
Sub_Exposure_Bias :
  /[0] 255
  -[0] 0.5
  ^[0] 2
  /[0] {2*$1*$1}
  *[0] -1
  exp[0]
  s[0] c # 1,2,3
  *[0] [2]
  rm[2]
  *[0] [1]
  rm[1]

# Sub, Pyramid bluring
Sub_BlurPyramid :
  # Calculate size
  size={0,min(w,h)}
  levels={round(log($size)/log(5))}
  Deviation=1

  # Scale down and blur
  b[0] $Deviation,1,1 # Blur image 100
  repeat $levels-1
    +resize. 50%,50%,5,1 # Scale subsequently down, create {$levels-1} images
    b. $Deviation,1,1 # Blur scaled image
  done

  # Scale up and blend
  blndalpha=0.5
  repeat $levels-1
    index={-($<+1)} # Image index to blend, start at next step of pyramid and progress to smaller iteratins
    resize[$index] [0],5,1
    blend[0,$index] alpha,$blndalpha,0
    blndalpha={$blndalpha/2} # Reduce opacity of blending by factor of 2 on each iteration
  done

# Main, Combined weight
fx_ExposureWeightMap :
  wc=$1
  ws=$2
  sigma=$3
  we=$4
  BlurMap=$5
  to_rgb[0]
  +Sub_Contrast_Bias[0] # CB, 0,1
  +Sub_Saturation_Bias[0] # SB, 0,1,2
  +Sub_Exposure_Bias[0] $sigma # EB, 0,1,2,3
  rm[0] # 0,1,2
  # Weight W=CB^wc+SB^ws+EB^we
  ^[0] $wc
  ^[1] $ws
  ^[2] $we
  +[0] [1]
  +[0] [2]
  k[0]
  n[0] 0,255
  # Blur mask
  if $BlurMap==1
    sub_BlurPyramid[0]
  fi

fx_ExposureWeightMapPreview :
  gui_split_preview "fx_ExposureWeightMap ${1--2}",$-1

############################
# Smooth sketch
############################
#@gui Smooth Sketch : fx_SmoothSketch, fx_SmoothSketch_preview(0)
#@gui : note = note("Convert image to black and white sketch. By default gradient edges are used but if filter input set to Active and Below a premade edge layer can be used from the layer below. Sketch strength slider will not have any effect if premade edges layer is used.")
#@gui : sep = separator()
#@gui : note = note("Sketch and edges")
#@gui : Create Sketch = bool(1)
#@gui : Sketch Strength = float(6,0,20)
#@gui : Sharpness = float(0.8,0,1)
#@gui : Anisotropy = float(0.3,0.1,1)
#@gui : Smoother Scaling = float(0.3,0.1,2.5)
#@gui : Smoother Degradation = float(0,0,1)
#@gui : Smoothing Amplitude = float(1000,1,3000)
#@gui : Smudge Angle = float(0,-180,180)
#@gui : sep = separator()
#@gui : note = note("Empty area coloring")
#@gui : Coloring Density = float(50,0,200)
#@gui : Coloring Stroke Length = float(10,0,100)
#@gui : Coloring Style = choice(2,"Linear","Angular","Linear wavy","Angular wavy")
#@gui : Coloring Opacity = float(0.6,0,1)
#@gui : sep = separator()
#@gui : note = note("Post processing parameters")
#@gui : Post Gamma = float(0.55,0.1,2)
#@gui : Fast = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2014/08/31</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/groups/gmic/discuss/72157628307225747")
fx_SmoothSketch :
  UsmRadius=5
  CreateSketch=$1
  UsmAmount=$1
  Sharpness=$2 # Sharpness for diffusion tensor
  Anisotropy=$3
  SmScale=$4
  SmAccuracy={$5}
  Amplitude=$6 # Smoothing ampliture
  fi=$7 # Rotation angle for tensor field
  Density=$8 # Noise density
  BlurLength=$9 # blur length
  Style=$10 # Bg Style selection
  BgOpacity=$11 # Bg blend opacity
  PostGamma=$12 # Gamma correction
  OptimizedResult=$13

  if $OptimizedResult
    OriginalWidth={0,w}
    # Resize to 1024 width (all in case a bottom layer is included
    resize2dx 1024
    fx_smooth_selective. 5,0.5,5,1,0,0,24,0
  fi

  if $CreateSketch==1
    # Unsharp to enhance edges and detail
    # unsharp. $UsmRadius,$UsmAmount
    fx_unsharp. 0,$UsmRadius,30,$UsmAmount,0,1,1,1,0,0,0
    # Gradient norm for lines
    +gradient_norm.
    # Invert for white bg
    negate.
    # Normalize for max range
    n. 0,255
  fi

  # Noise gb for smudging
  # New white image
  (255;255;255)
  # Resize to image size
  ri. ..
  # Add noise
  fx_noise. $Density,0,3,0,0

  # Blur and deform bg according to choice
  if $Style==0
    fx_blur_linear. $BlurLength,0,135,500,1,3,0,0
  fi
  if $Style==1
    fx_blur_angular. $BlurLength,1.2,1.2,0,0,0
  fi
  if $Style==2
    fx_blur_linear. $BlurLength,0,135,500,1,3,0,0
    deform. {$Density/5}
  fi
  if $Style==3
    fx_blur_angular. $BlurLength,1.2,1.2,0,0,0
    deform. {$Density/5}
  fi

  # Blend bg and edge
  blend[-1,-2] multiply,$BgOpacity,0
  n. 0,255
  +diffusiontensors[0] $Sharpness,$Anisotropy,0.6,1.1,0 # Create diffusion tensor field from original.
  rotation3d 0,0,1,{$fi} # It seems this creates a new image "a rotation matrix" Subtract 45 because this gives sharp image at 0 degrees.
  mix_channels.. ({@0-2};{@3-5};{@6-8}) # Channel mixer is used here with the rotation matrix
  rm. # remove rotation matrix
  # Scale matrix, this was changed to static and
  # parameter used for diffusion tensor anisotropy
  *. {$SmScale/max(abs(iM),abs(im))}
  noise. {$SmAccuracy*max(abs(iM),abs(im))}
  rv[-1,-2]
  smooth. ..,$Amplitude
  k.
  apply_gamma. $PostGamma

  if $OptimizedResult
    resize2dx $OriginalWidth
  fi

fx_SmoothSketch_preview :
  gui_split_preview "fx_SmoothSketch ${1--2}",$-1

#****************************************
# Composition analysis
#****************************************
#@gui Composition Analysis : fx_CompositionAnalysis, fx_no_preview
#@gui : note = note("A tool to abstract the image for subjective composition analysis. Two different methods are available. Set filter output to New layers. For actual analysis the aesthetic sense of the artist is required.")
#@gui : Method = choice(0,"Thumbnail abstraction","Value and lines")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2015/01/17</i>.</small>")

sub_thumbnailabstraction :
  # To RGB
  to_rgb[0]
  IWidth={0,w}
  IHeight={0,w}
  # FInd out which is larger and scale accordingly
  if $IWidth>=$IHeight
    ScaleByWidth=1
  fi

  # Resize to 100 px on larger dimension
  if $ScaleByWidth==1
    +resize2dx[0] 200,5
    b. 2
    # Resize to 1024 px
    resize2dx. 1024,5
    # Segmentation
    fx_segment_watershed. 0.5,5,0,0

  elif
    +resize2dy[0] 200,5
    b. 2
    # Resize to 1024 px
    resize2dy. 1024,5
    # Segmentation
    fx_segment_watershed. 0.5,5,0,0
  fi
  # Resize to original size for output
  resize. [0]
  # Luminance analysis
  +rgb2lab[0]
  s. c
  rm[-1,-2]
  b. 10%
  n. 0,255
  blend[-1,-2] hardlight,1,1
  k.

sub_colors_and_lines :
  image_width={0,w}
  image_height={0,h}
  resize2dx 1024
  luminance[0]
  n 0,255
  to_rgb[0]
  fx_smooth_bilateral[0] 2,15,2,0,0,24,0
  fx_colormap[0] 0,0,3,3,0,0,0,255,255,255,255,0,0,0,255,0,0,0,255,255,255,0,255,0,255,0,255,255,0
  +fx_smooth_anisotropic[0] 300,0.1,1,0,10,1,1,1,0,1,1,0,0,24,0
  fx_gradient_norm. 0,0.5,0,100,1,0
  blend[0,1] multiply,1
  resize. $image_width,$image_height,1,3,5,1

fx_CompositionAnalysis :
  method=$1
  if $method==0 sub_thumbnailabstraction fi
  if $method==1 sub_colors_and_lines fi

#****************************************
# Blockism
#****************************************
#@gui Blockism : fx_blockism, fx_blockism_preview(1)
#@gui : note=note("Renders rectangles on to the image.")
#@gui : note=note("Parameters")
#@gui : Relative Size = float(3,0,20)
#@gui : Ratio = float(1.6,1,10)
#@gui : Size Variance = float(0.5,0,10)
#@gui : Relative Block Count = int(50,0,500)
#@gui : Opacity = float(0.5,0,1)
#@gui : Flip Tolerance = int(64,0,255)
#@gui : Reverse Flip = bool(0)
#@gui : Quick = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/8063058705/")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2012/10/07</i>.</small>")
fx_blockism:
  XSize={int($1/100*w)}
  if $XSize==0 XSize=1 fi
  Ratio=$2
  Variance={int($3*$XSize)}
  Randomness=-1,1
  Repeats={int($4/100*max(w,h))}
  Opacity=$5
  FlipTol=$6
  ReverseFlip=$7
  LAB=1-$8
  # Calculate Y size and max size for the block
  YSize={int($Ratio*$XSize)}
  MaxXSize={int($XSize+$Variance)}
  MaxYSize={int($MaxXSize*$Ratio)}
  # Force RGB (remove alpha)
  to_rgb[0]
  # Split image to LAB channels if not quick
  if $LAB
    rgb2lab[0]
    s[0] c
  fi
  # Render blocks
  repeat $!
    # Take copy of the last image in the stack for grey value checking
    .
    repeat $Repeats
      # Random point from canvas to draw the block on
      X={int(u(-1,w))}
      Y={int(u(-1,h))}
      # If the value is below threshold then invert width and length
      # note that quick uses only Red channel to flip
      if $ReverseFlip==0
 if i($X,$Y,0,0)>$FlipTol
   # Calculcate block size. Interpolate linearly with random value
   # Linear interpolation is
   # y=ya+(yb-ya)(x-xa)/(xb-xa)
   # x is random value between -1 and 1
   # ya is minimum block size
   # yb is maximum block size
   # y is block size
   # abs is used to invert negative values to positive
   BW={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
   BH={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
 fi
 if i($X,$Y,0,0)<=$FlipTol
   BH={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
   BW={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
 fi
      fi
      if $ReverseFlip==1
        if i($X,$Y,0,0)<$FlipTol
   BW={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
   BH={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
 fi
        if i($X,$Y,0,0)>=$FlipTol
   BH={int(abs($XSize+($MaxXSize-$XSize)*(u($Randomness))))}
   BW={int(abs($YSize+($MaxYSize-$YSize)*(u($Randomness))))}
 fi
      fi
      # Calcualte corners
      x0={int($X-$BW/2)}
      y0={int($Y-$BH/2)}
      x1={int($x0+$BW)}
      y1={int($y0+$BH)}
      # Draw a rectangle with the gray of the block center value  of the L, A or B channel
      rectangle.. $x0,$y0,$x1,$y1,$Opacity,{i($X,$Y,0,0)},{i($X,$Y,0,1)},{i($X,$Y,0,2)},{i($X,$Y,0,3)}
    done
    rm.
    mv. 0
  done
  if $LAB
    a[-3,-2,-1] c
    lab2rgb.
  fi

fx_blockism_preview :
 gui_split_preview "fx_blockism $1,$2,$3,{$4*10},$5,$6,$7,$8",$-1

#****************************************
# HDR black fixing
#****************************************
#@gui Night HDR Image Black Noise Correction: fx_fix_HDR_black, fx_fix_HDR_black_preview(0)
#@gui : note=note("Filter to remove blue, magenta and red noise from the black areas of HDR images. Filter is designed specifically for HDR night shots but may work on other images as well. Bilateral filtering and Haar Wavelets are used to filter the noise from the image and mask is used to apply the noise removal only to dark areas.")
#@gui : sep = separator(), note=note("Mask opacity settings, Black values must be lower than Highlight values. Tick Show mask to view mask and to see the effect of the sliders.")
#@gui : note = note("Black cutoff")
#@gui : X-Coord(1) = int(20,0,255)
#@gui : Y-Coord(1) = int(25,0,255)
#@gui : note = note("Highlight raising")
#@gui : X-Coord(2) = int(50,0,255)
#@gui : Y-Coord(2) = int(200,0,255)
#@gui : Show Mask = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2013/11/02</i>.</small>")
fx_fix_HDR_black:
  to_rgb[0]
  X1=$1
  Y1=$2
  X2=$3
  Y2=$4
  ShowMask=$5
  +fx_smooth_bilateral. 4,8,6,4,0 # 0,1
  fx_smooth_haar. 0.6,5,2,3,1,24 # 0,1
  +rgb2lab. # 0,1,2
  s. c # 0,1,2,3,4
  rm[-1,-2] # 0,1,2(luminance info of smoothed image only)
  fx_apply_curve. 0,$X1,$Y1,$X2,$Y2,-1,128,-1,128,-1,128,255,1,0,0,21,0
  if $ShowMask==0
    negate. # Negative of Luminance
    a[-2,-1] c # append luminance info to smoothed image
    to_rgba. # 0,1,force RGBA for 1
    blend[0,-1] alpha # Blend with original
    k[0]
  fi

fx_fix_HDR_black_preview :
  gui_split_preview "fx_fix_HDR_black ${1--2}",$-1

#****************************************
# Noise paint
#****************************************
#@gui Noise Painting : fx_noisepainting, fx_noisepainting_preview(0)
#@gui : note = note("A preprocess suggestion for the painting filter.")
#@gui : sep = separator(), note = note("Pre process for painting")
#@gui : Spread Noise = int(0,0,20)
#@gui : Additive Noise = int(0,0,30)
#@gui : Luminance Only = bool(0)
#@gui : sep = separator(), note = note("Painting abstration")
#@gui : Abstraction = int(5,1,10)
#@gui : Details Scale = float(2.5,0,5)
#@gui : Color = float(1.5,0,4)
#@gui : Smoothness = float(50,0,1000)
#@gui : Sharpen Shades = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small> Author: Arto Huotari Latest update : <i>2012/07/12</i>.</small>")
fx_noisepainting :
  DegrLarge=$1
  DegrSmall=$2
  Channel=$3
  Abstr=$4
  Details=$5
  Color=$6
  Smooth=$7
  Sharp=$8
  to_rgb[0]
  if $Channel Channel=3 else Channel=0 fi
  # Pre segmentation
  if $PreProcess fx_segment_watershed $EdgeThresh,$WaterSmooth,0,0 fi
  # Degradation with additive noise
  if $DegrLarge!=0 fx_spread $DegrLarge,$DegrLarge,0,0 fi
  # fx_noise 47.0046,2,3,0,0
  if $DegrSmall!=0 fx_noise $DegrSmall,2,$Channel,0,0 fi
  fx_painting $Abstr,$Details,$Color,$Smooth,$Sharp,0

fx_noisepainting_preview :
  gui_split_preview "fx_noisepainting ${1--2}",$-1

#****************************************
# BW film simulation
#****************************************
#@gui Black & White Film : fx_bwfilmsimulate, fx_bwfilmsimulate_preview(1)
#@gui : Film Type / RGB Balance = choice(0,"Manual","Agfa 200X","Agfapan 25","Agfapan 100","Agfapan 400","Iford Delta 100","Iford Delta 400","Iford Delta 400 pro & 3200","Ilford FP4","Ilford HP4","Ilford Pan F","Ilford SFX","Ilford XP2 Super","Kodak Tmax 100","Kodak Tmax 400","Kodak Tri-X")
#@gui : note = note("Simpler version available in main tree. This filter will be removed in future from testing. PM me if you need this for some reason.")
#@gui : note = note("RGB sliders work only with manual selection")
#@gui : Red Level = float(0.299,0,1)
#@gui : Red Smoothness = float(0,0,10)
#@gui : Green Level = float(0.587,0,1)
#@gui : Green Smoothness = float(0,0,10)
#@gui : Blue Level = float(0.114,0,1)
#@gui : Blue Smoothness = float(0,0,10)
#@gui : sep = separator()
#@gui : Gamma = float(1,0.01,5)
#@gui : Contrast = float(1,0,4)
#@gui : Brightness = float(0,-255,255)
#@gui : Hue = float(0,0,360)
#@gui : Saturation = float(0,0,1)
#@gui : sep = separator()
#@gui : Grain (Shadows) = float(0,0,200)
#@gui : Grain (Midtones) = float(0,0,200)
#@gui : Grain (Highlights) = float(0,0,200)
#@gui : Grain Tone Fading = float(2,0,10)
#@gui : Grain Scale = float(0,0,3)
#@gui : Grain Type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gui : sep = separator()
#@gui : Local Contrast = float(0,0,60)
#@gui : Radius = int(16,1,512)
#@gui : Contrast Smoothness = float(4,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>David Tschumperl&#233, Arto Huotari;</i>.      Latest update : <i>2019/09/28</i>.</small>")
fx_bwfilmsimulate :
  Choice=$1
  P1=$2
  P2=$3
  P3=$4
  P4=$5
  P5=$6
  P6=$7
  P7=$8
  P8=$9
  P9=$10
  P10=$11
  P11=$12
  P12=$13
  P13=$14
  P14=$15
  P15=$16
  P16=$17
  P17=$18
  P18=$19
  P19=$20
  P20=$21
  if $Choice==1 P1={18/255} P3={41/255} P5={41/255} fi
  if $Choice==2 P1={25/255} P3={39/255} P5={36/255} fi
  if $Choice==3 P1={21/255} P3={40/255} P5={39/255} fi
  if $Choice==4 P1={20/255} P3={41/255} P5={39/255} fi
  if $Choice==5 P1={21/255} P3={42/255} P5={37/255} fi
  if $Choice==6 P1={22/255} P3={42/255} P5={36/255} fi
  if $Choice==7 P1={31/255} P3={36/255} P5={33/255} fi
  if $Choice==8 P1={28/255} P3={41/255} P5={31/255} fi
  if $Choice==9 P1={23/255} P3={37/255} P5={40/255} fi
  if $Choice==10 P1={33/255} P3={36/255} P5={31/255} fi
  if $Choice==11 P1={36/255} P3={31/255} P5={33/255} fi
  if $Choice==12 P1={21/255} P3={42/255} P5={37/255} fi
  if $Choice==13 P1={24/255} P3={37/255} P5={39/255} fi
  if $Choice==14 P1={37/255} P3={36/255} P5={37/255} fi
  if $Choice==15 P1={25/255} P3={35/255} P5={40/255} fi

  repeat $!
    l. split_opacity rv to_rgb. s. c              # Isolate opacity
    *... $P1 b... $P2%                            # Red contrast + smoothness
    *.. $P3 b.. $P4%                              # Green contrast + smoothness
    *. $P5 b. $P6%                                # Blue contrast + smoothness
    +[-3--1] /. {$P1+$P3+$P5} c. 0,255            # (R,G,B) > B&W

    apply_gamma. $P7                              # Gamma correction
    -. 128 *. $P8 +. 128 +. $P9 c. 0,255          # B&W contrast and brightness.

    100%,100% .x2                                 # Create noise for shadows, midtones and highlights.
    noise... 100,$P17 b... $P16% n... -$P12,$P12  # Scaled grain on shadows.
    noise.. 100,$P17 b.. $P16% n.. -$P13,$P13     # Scaled grain on midtones.
    noise. 100,$P17 b. $P16% n. -$P14,$P14        # Scaled grain on highlights.

    +tones[-4] 3 b[-3--1] $P15%                   # Get smoothed tones.
    *[-6,-3] *[-4,-2] *[-2,-1]                    # Get noisy tones.
    +[-4--1] c. 0,255                             # Compose them with the B&W image.

    if $P10" || "$P11
      /. 255
      i.. 100%,100%,1,1,$P11
      i... 100%,100%,1,1,$P10
      a[-3--1] c hsv2rgb.
    fi

    rv a c done mv. 0 done                          # Re-compose opacity and loop to next image.
  normalize_local $P18,$P19,$P20,2%,1,0,255

fx_bwfilmsimulate_preview :
  gui_split_preview "fx_bwfilmsimulate ${1--2}",$-1

#****************************************
# Warp test
#****************************************
#@gui Warp Test : fx_WarpTest, fx_WarpTest
#@gui : sep = separator()
#@gui : note=note("Two layers required if automap is not used. <b>Set input to active and below</b>. Filter offsetts image with a vector field map. Map is created from R and G channels so that R128,G128 becomes [0 0]. Experiment with solid 128,128,0 color layer and add hues of red and green. Angle shift rotates the vector field and Zero point offset moves the default 0 0 point. This is mainly for fun and testing.")
#@gui : sep = separator()
#@gui : Map Type = choice("Automap","Layer Map")
#@gui : Angle Shift = float(0,-180,180)
#@gui : Zero Point Offset = float(0,-128,128)
#@gui : Vector Length Multipler = float(1,0.1,128)
#@gui : sep = separator()
#@gui : note = note("Optional viewing of vector field")
#@gui : Show Quiver = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2012/02/28</i>.</small>")
fx_WarpTest :
  # Variables
  MapType=$1
  fi={$2*3.1415/180}
  ZeroOffset=$3
  LMult=$4
  ShowQuiver=$5

  if $MapType==0
    +fx_local_orientation 0.5,0,100,0,4,0
  fi

  # Angles for rotation
  cosfi={cos($fi)}
  sinfi={sin($fi)}

  to_rgb[-2,-1]
  # Set origin 128,128 to 0,0
  -. {128+$ZeroOffset}
  s. c # there were 2 images in the stack, now there are 4, 0,1,2,3, -1 was used in split
  # Force blue channel to 0
  *[3] 0
  # Channel -3 = X values = image [1]
  # Channel -2 = Y values = image [2]
  # Channel -1 is zero = image [3]
  # Rotation for X coord is x'=Xcosfi-Ysinfi
  # Calculate first Xcosfi and Ycosfi to new image
  +*[1] $cosfi # xcosfi this is now image 4
  +*[2] $sinfi # ysinfi this is now image 5
  # Calculate new X coord
  -[4] [5]
  rm[5]
  # Calculate new Y coord x'=Xsinfi+Ycosfi
  +*[1] $sinfi # xsinfi this is now image 5
  +*[2] $cosfi # yxosfi this is now image 6
  +[5] [6]
  rm[6]
  rm[1,2] # Image 3 becomes 1, 4x' becomes 2 and 5y' becomes 3
  rm[1]  # Image 1z deleted, 2x' becomes 1 and 3y' becomes 2
  100%,100%,100%,1,0
  a[1,2,3] c
  # Divide with 128 to "normalize" between -1 1 (not true for non zero offsets)
  /. {128/$LMult}
  channels. 0,1
  if $ShowQuiver==0
#  vector2tensor.
#  smooth.. .,$Amplitude
    warp.. .,1,1,0
  fi
  if $ShowQuiver==1
    quiver.. .,10,{$LMult/100},1,0.8,255
  fi
  rm.

#****************************************
# Dodge sketch
#****************************************
#@gui Dodge Sketch : fx_dodgesketch, fx_dodgesketchpreview(0)
#@gui : note = note("Simple BW sketch"),note = link("Method is described here","http://www.gimpusers.com/tutorials/making-a-pencil-drawing-from-a-photo.html")
#@gui : note = note("in addition an option to color the sketch is included")
#@gui : sep = separator(), note = note("Power setting for sketch")
#@gui : Power = int(3,0,10)
#@gui : sep = separator(), note = note("Presmoothing settins of bilateral filter")
#@gui : Spatial Variance = float(10,0,100)
#@gui : Value Variance = float(7,0,100)
#@gui : Iterations = int(2,1,10)
#@gui : sep = separator()
#@gui : Colored? = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
fx_dodgesketch:
  # Remove alpha channel
  to_rgb[0]
  Power=$1
  SpatialVariance=$2
  ValueVariance=$3
  Iterations=$4
  Colored=$5

  # Remove color, add as new incase org can be later used for "colored"
  +fx_mix_hsv[0] 1,0,0,0,-1,0,1,0,0,0,2,0
  # Smooth with bilateral filter
  +fx_smooth_bilateral. $SpatialVariance,$ValueVariance,$Iterations,0,0
  # Invert colors of smoothed image
  negate.
  # Compose inverted image with 0.5 opacity to BW
  blend[-1,-2] alpha,0.5,0
  # Take duplicate of previous
  .
  # Make BW lines
  +blend[-1,-2] dodge,1,0
  # Clear mem
  k[0,-1]

  # Use repeat loop to multiply the sketch
  repeat $Power
    .
    blend[-1,-2] multiply
  done

  if $Colored==1
    +blend[-1,-2] hardlight # image -1 i.e. image 3
    rm..
    fx_transfer_colors[-1,-2] 0,0
  fi
  k.

fx_dodgesketchpreview :
  gui_split_preview "fx_dodgesketch ${1--2}",$-1

#****************************************
# MappedSmoothing
#****************************************
#@gui Mapped Smoothing : fx_MappedSmooth, fx_MappedSmooth
#@gui : sep = separator()
#@gui : note=note("Two layers required if automap is not used. <b>Set input to active and below</b>. Filter Smooths image with a vector field map. Map is created from R and G channels so that R128,G128 becomes [0 0]. Experiment with solid 128,128,0 color layer and add hues of red and green. Angle shift rotates the vector field and Zero point offset moves the default 0 0 point. This is somewhat a development version, sample art is still missing.")
#@gui : sep = separator()
#@gui : Map Type = choice("Automap","Layer Map")
#@gui : Angle Shift = float(0,-180,180)
#@gui : Zero Point Offset = float(0,-128,128)
#@gui : Amplitude = float(300,10,10000)
#@gui : Vector Length Multipler = float(1,0.1,5)
#@gui : sep = separator()
#@gui : note = note("Optional viewing of vector field")
#@gui : Show Quiver = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2012/02/25</i>.</small>")
fx_MappedSmooth :
  # Variables
  MapType=$1
  fi={$2*3.1415/180}
  ZeroOffset=$3
  Amplitude=$4
  LMult=$5
  ShowQuiver=$6

  if $MapType==0
    +fx_local_orientation 0.5,0,100,0,4,0
  fi

  # Angles for rotation
  cosfi={cos($fi)}
  sinfi={sin($fi)}

  to_rgb[-2,-1]
  # Set origin 128,128 to 0,0
  -. {128+$ZeroOffset}

  s. c # There were 2 images in the stack, now there are 4, 0,1,2,3, -1 was used in split
  # Force blue channel to 0
  *[3] 0
  # Channel -3 = X values = image [1]
  # Channel -2 = Y values = image [2]
  # Channel -1 is zero = image [3]
  # Rotation for X coord is x'=Xcosfi-Ysinfi
  # Calculate first Xcosfi and Ycosfi to new image
  +*[1] $cosfi # xcosfi this is now image 4
  +*[2] $sinfi # ysinfi this is now image 5
  # Calculate new X coord
  -[4] [5]
  rm[5]
  # Calculate new Y coord y'=Xsinfi+Ycosfi
  +*[1] $sinfi # xsinfi this is now image 5
  +*[2] $cosfi # yxosfi this is now image 6
  +[5] [6]
  rm[6]
  rm[1,2] # Image 3 becomes 1, 4x' becomes 2 and 5y' becomes 3
  rm[1]  # Image 1z deleted, 2x' becomes 1 and 3y' becomes 2
  100%,100%,100%,1,0
  a[1,2,3] c
  # Divide with 128 to "normalize" between -1 1 (not true for non zero offsets)
  /. {128/$LMult}
  channels. 0,1
  if $ShowQuiver==0
    vector2tensor.
    smooth.. .,$Amplitude
  fi
  if $ShowQuiver==1
    quiver.. .,10,{$Amplitude/20},1,0.8,255
  fi
  rm.

#****************************************
# Gimp Rotation Demo
#****************************************
#@gui Vector Field Rotation Demo : fx_DemoVecRot, fx_DemoVecRot
#@gui : note=note("Vector field rotation and quiver sample")
#@gui : Angle Shift = float(0,-180,180)
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i> with help from <i>David Tschumperl&#233;</i>.     Latest update : <i>2012/02/25</i>.</small>")
fx_DemoVecRot :
  angle=$1
  # Force to RGB (remove possible alpha channel)
  to_rgb[0]
  # Take a copy of the input to work on
  [0]
  # Force the copy to RGB just in case. This is not actually needed and just takes time.
  to_rgb.
  # Split image along channels
  s. c
  # Subtract 128 from red and green channels
  -.. 128
  -... 128
  # Append channels back to one image
  a[-3,-2,-1] c
  # Drop third channel from the field
  # other vise matrix multiplication at rotation and quiver will not work
  channels. 0,1
  # Divide by 128 to scale length
  /. 128
  # Rotation code from David
  # 200,200,1,2 200x200x1 px only two channels
  rotation3d 0,0,1,$angle # It seems this creates a new image "a rotation matrix"
  z. 0,0,1,1 # This crops the rotation matrix, I do not know why
  mix_channels.. ({@0-1};{@2-3}) # Channel mixer is used here with the rotation matrix
  rm. # remove rotation matrix
  # End rotation code
  # Quiver takes only two channels in. It will give an error othervise
  quiver.. .,10,10,1,0.8,255
  k..

#****************************************
# Structure tensors
#****************************************
#@gui GMic Structure Tensors : fx_StructureTensors, fx_StructureTensorsPreview(0)
#@gui : sep = separator()
#@gui : note = note("Structure tensors calculation for Gimp plugin. This is just an interface to built in GMic Structure tensors command")
#@gui : Power = float(0.1,0.1,2)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2011/12/06</i>.</small>")
##@gui : note = link("Filter Explained here","http://gmic.sourceforge.net/reference.shtml")
fx_StructureTensors:
  structuretensors abs ^ $1
  n 0,255

fx_StructureTensorsPreview :
  gui_split_preview "fx_StructureTensors ${1--2}",$-1

#****************************************
# Old Make Squiggly
#****************************************
#@gui Make Old Squiggly : fx_OldSquiggly, fx_OldSquiggly
#@gui : note = note("Development version. This version will be removed in future from sources so if you prefer this then copy and save the source to your local .gmic file")
#@gui : Spread Noise Amount  = float(2,0,20)
#@gui : Segmentation Edge Threshold = float(12,0,15)
#@gui : Segmentation Smoothness = float(0.8,0,5)
#@gui : GradienNormSmoothness = float(0,0,10)
#@gui : GradienNormLinearity = float(0.5,0,1.5)
#@gui : IncreaseChroma1 = float(3,1,4)
#@gui : Tone Threshold = float(0.2,0,1)
#@gui : Tone Gamma = float(0.4,0,1)
#@gui : Paper Grayness = int(50,0,255)
#@gui : Paper Whiteness = int(245,0,255)
#@gui : Squiggle Gamma = int(45,1,128)
#@gui : Squiggle Multiplier = float(0.5,0,1)
fx_OldSquiggly :
  +fx_spread[0] $1,$1,0,0  # Spread noise (image1)
  fx_segment_watershed[1] $2,$3,0,0   # Segmentation (image1)
  +fx_gradient_norm[1] $4,$5,0,100,0,0 # Gradient norm (image2)

  # Create colorized squiggle
  +blend[2,1] multiply # image 3
  # Increase chroma threes have been modified from 1 and
  fx_mix_ycbcr[3] 1,0,0,$6,0,0,$6,0,0,0,2,0 # image 3

  # Tonemap original
  fx_map_tones[0] $7,$8,0.1,30,0,0 # image 0
  # fx_apply_curve[0] 0,30,128,-1,128,-1,128,-1,128,-1,128,255,1,3,0,0,0
  # Compose Squigglies to original
  blend[0,3] darken # it seems image 3 is destroyed in this op.

  rm[1,2] # remove extra images to save memory 3->0

  # Create paper
  # +fx_plasma 0.5,10 # Image 1
  +fx_plasma 0.5,10,8,0 # Image 1
  fx_blackandwhite[1] 0.299,0,0.587,0,0.114,0,1,1,0,0,0,0,0,0,2,0,0,0,16,4,0,0,0
  # adjust paper lightness, 7 and 215 need to be parameters
  fx_apply_curve[1] $9,-1,128,-1,128,-1,128,-1,128,-1,128,$10,1,3,0,0,0

  # Adjust squiggly
  fx_apply_curve[0] 0,$11,128,-1,128,-1,128,-1,128,-1,128,255,1,3,0,0,0

  # Combine paper and squiggly
  *[0] {0.5*(1+$12)}
  *[1] {0.5*(1-$12)}

  ++[0] [1] # image 2

  +blend[0,2] softlight # image 3
  rm[0,1,2]

#***********************************
# AbstractFlood
#************************************
#@gui Abstract Flood : fx_AbstractFlood, fx_AbstractFlood_Preview(1)
#@gui : sep = separator()
#@gui : note = note("Warning: Really really slow filter especially with Cubism enabled. Use a maximum of 1 megapixel image. Random walk algorihm is used to select new areas to flood. If Cubism is enabled the filter has to run cubims for every succesful repeat defined in the flood settings section.")
#@gui : Preprocess with Bilateral Filtering = bool(1)
#@gui : Spatial Variance = float(10,0,100)
#@gui : Value Variance = float(7,0,100)
#@gui : Iterations = int(2,1,10)
#@gui : sep = separator()
#@gui : note = note("Flood settings")
#@gui : Activate Flood = bool(0)
#@gui : Repeats = int(10,1,1000)
#@gui : Flood Tolerance = int(5,0,100)
#@gui : Flood Base Step = int(3,1,10)
#@gui : Canvas Color = color(255,255,255,255)
#@gui : sep = separator()
#@gui : note = note("Abstraction setting, Consider disabling preview if using high flood repeats!")
#@gui : Activate Cubism = bool(0)
#@gui : Cubism Iterations = int(300,1,2000)
#@gui : Bloc Size = float(10,0,40)
#@gui : Angle = float(90,0,360)
#@gui : Opacity = float(0.7,0.01,1)
#@gui : Smoothness = float(0,0,5)
#@gui : note = note("Opacity threshold used to make decision about flooding. Use 0 if Cubism is not enabled.")
#@gui : Opacity Tolerance = int(0,0,254)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Arto Huotari</i>.      Latest update : <i>2013/09/28</i>.</small>")
#@gui : note = link("Filter Explained here","http://www.flickr.com/photos/naggobot/6243715666")
fx_AbstractFlood :

  # Parameters from input
  Prep=$1
  SpatialVariance=$2
  ValueVariance=$3
  Iterations=$4
  ActivateFlood=$5
  Repeats=$6
  Tolerance=$7
  FloodBaseStep=$8
  CanvasR=$9
  CanvasG=$10
  CanvasB=$11
  Opacity=$12
  ActivateCubism=$13
  CubismIterations=$14
  Blocsize=$15
  Angle=$16
  CubismOpacity=$17
  Smoothness=$18
  StepThreshold={$19+0.1} # Threshold for opacity, has pixel been flooded or not

  Step=$FloodBaseStep
  Delta=1 # Base step addition i.e. how much the bug step is increased if the pixel was not good place to make flood
  # Save delta org for later use
  DeltaOrg=$Delta

  # Add alpha channel to original just in case
  to_rgba[0]

  # Preprocess with bilateral filtering
  if $Prep==1
    fx_smooth_bilateral[0] $SpatialVariance,$ValueVariance,$Iterations,0,0 # image 0
  fi
  # Make bg for composing. Bg is transparent so that alpha can be used to
  # determine if operation should be done.
  ({$CanvasR}^{$CanvasG}^{$CanvasB}^0) # image 1

  to_rgba[1] # force to RGBA just in case
  ri[1] [0] # resize to image size

  # Start pattern from centre and proceed
  # with random walk. start/centre point is
  X={(w)/2}
  Y={(h)/2}
  # Grab image h and w for later use
  ImageH={(h)}
  ImageW={(w)}

  # Set DoLoop decision parameters for later use
  DoLoop=0
  IsGood=0

  # Go to loop if ActivateFlood = 1
  if $ActivateFlood==1

    # A comment here is needed
    repeat $Repeats

      # The actual flood is done by this
      # ellipse {100*$X/w}%,{100*$Y/h}%,{1},{1},{0},1,255,0,255
      flood[0] {100*$X/w}%,{100*$Y/h}%,0,$Tolerance,0,1,{0,i($X,$Y,0,0)},{0,i($X,$Y,0,1)},{0,i($X,$Y,0,2)},{0,i($X,$Y,0,3)} # Img0

      # Select the color that was flooded + others pixels of same color
      +fx_select_color[0] 0,1,0,{0,i($X,$Y,0,0)},{0,i($X,$Y,0,1)},{0,i($X,$Y,0,2)},{0,i($X,$Y,0,3)},0,0 # image2

      if $ActivateCubism==1
 # Treat color with Cubism
 cubism[2] $CubismIterations,$Blocsize,$Angle,$CubismOpacity,$Smoothness
      fi

       # Compose with alpha blending mode
       blend[1,2] alpha

       # Calculate new coordinate in do while loop until
       # new coordinate has opacity lower than threshold
       # and new coordinate is whitin image boundary

      do
        # Random step length is minimum step + delta which is dependent on how many attempts have been made
        Rstep={$Step+$Delta}
 # Random direction to go to
 theta={u(360)}
 # Add to previous coordinate to get new coord

 Xnew={int($X+$Rstep*cos($theta))}
 Ynew={int($Y+$Rstep*sin($theta))}

 # Check if new coordinate is good ie whitin image
 if $Xnew>0" && "$Xnew<$ImageW" && "$Ynew>0" && "$Ynew<$ImageH
   # If coord was good set as new 'bug' location
   X=$Xnew
   Y=$Ynew
   # Check the alpha of new coord. If above threshold increase delta
   if {1,i($X,$Y,0,3)>$StepThreshold}
     # Increase delta if no suitable pixel could be found on previous step
     # Delta is smaller of the previous
     # Base step size + do while loop number # or#  one tenth of maximum image dimension
     Delta={min({$Delta+$Delta*2},{max($ImageW,$ImageH)/5})}
   fi

   # Check the alpha of new coord,
   # if below threshold exit do-while and flood
   if {1,i($X,$Y,0,3)<$StepThreshold}
     IsGood=10
   fi
   # Make sure that loop will be eventuall exited, run a max of 100 do-while loops
   if $DoLoop>100
     IsGood=10
   fi
 fi
 # Increase do loop counter
        DoLoop=$DoLoop+1
 # Continue until IsGood has been set to 10
      while $IsGood<1

      # Set trigger to bad i.e 0
      IsGood=0
      DoLoop=0
      Delta=$DeltaOrg
    done
  fi

  # Create specified color BG and Compose
  ({$CanvasR}^{$CanvasG}^{$CanvasB}^{$Opacity}) # image 2
  ri[2] [0]
  rv[1,2]
  blend[1,2] alpha

  # Keep only result
  if $ActivateFlood==1
    k[1]
  elif $ActivateFlood==0
    k[0]
  fi

fx_AbstractFlood_Preview :
  gui_split_preview "fx_AbstractFlood ${1--2}",$-1

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
